<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Dynamic Code Brand Checks
stage: 1
contributors: Krzysztof Kotowicz, Mike Samuel
</pre>

<p>
See also the
<a href="https://github.com/tc39/dynamic-code-brand-checks">explainer</a>.</p>

<h2>Background</h2>

<p>The <a href="https://w3c.github.com/webappsec-trusted-types/">Trusted Types proposal</a>
(<a href="https://docs.google.com/presentation/d/e/2PACX-1vQCbxmHKjPWUq7MC91x6tJKanFYU2i9Z13wwfkngcseHt96EfU_xyA0awkxb4SoNW3hQ3S2z-ByX0T9/pub?start=false&loop=false&delayms=60000">explainer for TC39</a>)
seeks to guard risky operations like dynamic code evaluation by requiring
that code portions have a runtime type that indicates that they have
been explicitly trusted.</p>

<p>Specifically, when Trusted Types enforcement is turned on, it would like to ensure
that arguments to <code>eval(x)</code> and <code>new Function(x)</code> are
(or are convertible to)
<a href="https://w3c.github.io/webappsec-trusted-types/dist/spec/#typedef-trustedscript">TrustedScript</a>.
This enhances the existing dynamic code evaluation guards that the web platform already controls with <a href="https://w3c.github.io/webappsec-csp/">Content Security Policy</a>.</p>

<h3>Problem 1: %eval% does not accept objects in lieu of strings for code</h3>

<p>PerformEval exits early when its argument is not a string.</p>

<emu-alg>
  2. If Type(_x_) is not String, return _x_.
</emu-alg>

<p>This proposal relaxes the "Type(x) is String" requirement for inputs to `eval`
to enable restricting dynamic code loading to values that have been
attested to previously.</p>

<ul>
 <li>Adds an algorithm, <emu-xref aoid="IsCodeLike">IsCodeLike</emu-xref>
   that returns *true* for some objects ordained by the hosts to be code-like.
   See the options below for details of which objects are code-like.</li>
 <li>Tweaks <a href="https://tc39.github.io/ecma262#sec-performeval">PerformEval</a>
   to use IsCodeLike and to coerce the code to a string.</li>
</ul>


<h3>Problem 2: host callout does not receive type information</h3>

<p>Currently, the information available to the check is per-realm:</p>

<emu-alg>
  5. Perform ? HostEnsureCanCompileStrings(_callerRealm_, _calleeRealm_).
</emu-alg>

<p>This proposal aims to provide additional context to HostEnsureCanCompileStrings,
and reorder the steps in CreateDynamicFunction so that HostEnsureCanCompileStrings
knows if all the input arguments were code-like.</p>

<h3>Problem 3: host callout cannot adjust values</h3>

<p>In Trusted Types, the
<a href="https://wicg.github.io/trusted-types/dist/spec/#default-policy-hdr">default policy</a>'s
<a href="https://wicg.github.io/trusted-types/dist/spec/#callbackdef-createscriptcallback"
 >`createScript` callback</a> returns a value that is used in place of the input.
For example, if the default policy's `createScript` callback returns `"output"` given
`"input"` then `eval("input")` would load and run a |ScriptBody| parsed from the source text
`output`.
</p>

<pre><code class="html">
&lt;meta http-equiv="Content-Security-Policy" content="require-trusted-types-for 'script'" /&gt;
&lt;script&gt;
// Define a default policy that maps the source text `input` to `output`.
window.trustedTypes.createPolicy(
  'default',
  {
    createScript(code) {
      if (code === 'input') { return 'output'; }
      throw new Error('blocked script execution');
    },
  });

globalThis.input = 1;
globalThis.output = 2;
// The source text loaded is `output`
eval('input') === globalThis.output;  // true
&lt;/script&gt;
</code></pre>

<p>This proposal adjusts callers of the callback to expect a result and to use it in place
of the inputs.</p>

<h3>Problem 4: host callout doesn't pass the code to check</h3>

<p><a href="https://tc39.es/ecma262/#sec-hostensurecancompilestrings">HostEnsureCanCompileStrings</a>
callout only passes the realms to the host environment. In the web platform,
that callout is hooked to the <a href="https://w3c.github.io/webappsec-csp/#should-block-inline">Content Security Policy algorithms</a>,
which take action based on <em>code</em> that is to be executed - e.g. an eval() argument, or
a dynamically-created function body, at least to be able to include that code in <a href="https://w3c.github.io/webappsec-csp/#security-violation-reports">violation reports</a>.
As such, some implementations (v8 and SpiderMonkey) actually also pass the code string
to the host, and in the case of <code>new Function()</code> perform the callout
later in <a href="https://tc39.es/ecma262/#sec-createdynamicfunction">CreateDynamicFunction</a>,
after the function body is assembled.
</p>
<p>This proposal updates the host callout to contain the script to be executed,
and moves the callout in CreateDynamicFunction after the function body is assembled.</p>


<emu-clause id="sec-iscodelike" aoid="IsCodeLike">
  <h1><ins>Runtime Semantics: IsCodeLike ( _x_ )</ins></h1>
  <p><ins>The abstract operation IsCodeLike with arguments _x_ checks if _x_ contains the host-defined [[HostDefinedCodeLike]] internal slot. It performs the following steps:</ins></p>
  <emu-alg>
    1. <ins>If _x_ has a [[HostDefinedCodeLike]] internal slot, then return *true*.
    1. <ins>Return *false*.</ins>
  </emu-alg>
</emu-clause>

<emu-clause id="sec-hostvalidatedynamiccode" aoid="HostValidateDynamicCode">
        <h1><del>HostEnsureCanCompileStrings</del> <ins>HostValidateDynamicCode</ins> ( _callerRealm_, _calleeRealm_<ins>, _codeString_, _wasCodeLike_</ins>)</h1>
        <p><del>HostEnsureCanCompileStrings</del> <ins>HostValidateDynamicCode</ins> is a host-defined abstract operation that allows host environments to <del>block</del><ins>guard</ins> certain ECMAScript functions which allow developers to compile strings into ECMAScript code.</p>
        <p>An implementation of <del>HostEnsureCanCompileStrings</del> <ins>HostValidateDynamicCode</ins> may complete normally or abruptly. Any abrupt completions will be propagated to its callers. The default implementation of <del>HostEnsureCanCompileStrings</del><ins>HostValidateDynamicCode</ins> is to unconditionally return a NormalCompletion(_codeString_).</p>
</emu-clause>


<emu-clause id="sec-performeval" aoid="PerformEval">
  <h1>Runtime Semantics: PerformEval ( _x_, _callerRealm_, _strictCaller_, _direct_ )</h1>
  <p>The abstract operation PerformEval with arguments _x_, _callerRealm_, _strictCaller_, and _direct_ performs the following steps:</p>
  <emu-alg>
    1. Assert: If _direct_ is *false*, then _strictCaller_ is also *false*.
    1. <ins>Let _isCodeLike_  be ! IsCodeLike(_x_).</ins>
    1. If Type(_x_) is not String <ins>and _isCodeLike_ is *false*</ins>, return _x_.
    1. Let _evalRealm_ be the current Realm Record.
    1. <del>Perform ? HostEnsureCanCompileStrings(_callerRealm_, _calleeRealm_).</del><br>
       <ins>Set _x_ to be ? ToString(HostValidateDynamicCode(_callerRealm_, _calleeRealm_, ToString(_x_), _isCodeLike_)).</ins>
    1. ...
  </emu-alg>
</emu-clause>


<emu-clause id="sec-createdynamicfunction" aoid="CreateDynamicFunction">
  <h1>CreateDynamicFunction ( _constructor_, _newTarget_, _kind_, _args_ )</h1>
  <p>The abstract operation CreateDynamicFunction takes arguments _constructor_ (a constructor), _newTarget_ (a constructor), _kind_ (either ~normal~, ~generator~, ~async~, or ~asyncGenerator~), and _args_ (a List of ECMAScript language values). _constructor_ is the constructor function that is performing this action. _newTarget_ is the constructor that `new` was initially applied to. _args_ is the argument values that were passed to _constructor_. It performs the following steps when called:</p>
  <emu-alg>
    1. Assert: The execution context stack has at least two elements.
    1. Let _callerContext_ be the second to top element of the execution context stack.
    1. Let _callerRealm_ be _callerContext_'s Realm.
    1. Let _calleeRealm_ be the current Realm Record.
    1. <del>Perform ? HostEnsureCanCompileStrings(_callerRealm_, _calleeRealm_).</del>
    1. If _newTarget_ is *undefined*, set _newTarget_ to _constructor_.
    1. If _kind_ is ~normal~, then
      1. Let _goal_ be the grammar symbol |FunctionBody[~Yield, ~Await]|.
      1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, ~Await]|.
      1. Let _fallbackProto_ be *"%Function.prototype%"*.
    1. Else if _kind_ is ~generator~, then
      1. Let _goal_ be the grammar symbol |GeneratorBody|.
      1. Let _parameterGoal_ be the grammar symbol |FormalParameters[+Yield, ~Await]|.
      1. Let _fallbackProto_ be *"%GeneratorFunction.prototype%"*.
    1. Else if _kind_ is ~async~, then
      1. Let _goal_ be the grammar symbol |AsyncFunctionBody|.
      1. Let _parameterGoal_ be the grammar symbol |FormalParameters[~Yield, +Await]|.
      1. Let _fallbackProto_ be *"%AsyncFunction.prototype%"*.
    1. Else,
      1. Assert: _kind_ is ~asyncGenerator~.
      1. Let _goal_ be the grammar symbol |AsyncGeneratorBody|.
      1. Let _parameterGoal_ be the grammar symbol |FormalParameters[+Yield, +Await]|.
      1. Let _fallbackProto_ be *"%AsyncGeneratorFunction.prototype%"*.
    1. Let _argCount_ be the number of elements in _args_.
    1. Let _P_ be the empty String.
    1. <ins>Let _assembledFromCodeLike_ be *true*.</ins>
    1. If _argCount_ = 0, let _bodyArg_ be the empty String.
    1. Else if _argCount_ = 1, <del>let _bodyArg_ be _args_[0]</del>.
      1. <ins>Let _bodyArg_ be _args_[0].</ins>
      1. <ins>If IsCodeLike(_bodyArg_) is *false*, set _assembledFromCodeLike_ to *false*.</ins>
    1. Else,
      1. Assert: _argCount_ &gt; 1.
      1. Let _firstArg_ be _args_[0].
      1. <ins>If IsCodeLike(_firstArg_) is *false*, set _assembledFromCodeLike_ to *false*.</ins>
      1. Set _P_ to ? ToString(_firstArg_).
      1. Let _k_ be 1.
      1. Repeat, while _k_ &lt; _argCount_ - 1,
        1. Let _nextArg_ be _args_[_k_].
        1. <ins>If IsCodeLike(_nextArg_) is *false*, set _assembledFromCodeLike_ to *false*.</ins>
        1. Let _nextArgString_ be ? ToString(_nextArg_).
        1. Set _P_ to the string-concatenation of _P_, *","* (a comma), and _nextArgString_.
        1. Set _k_ to _k_ + 1.
      1. Let _bodyArg_ be _args_[_k_].
      1. <ins>If IsCodeLike(_bodyArg_) is *false*, set _assembledFromCodeLike_ to *false*.</ins>
    1. Let _bodyString_ be the string-concatenation of 0x000A (LINE FEED), ? ToString(_bodyArg_), and 0x000A (LINE FEED).
    1. Let _prefix_ be the prefix associated with _kind_ in <emu-xref href="#table-dynamic-function-sourcetext-prefixes"></emu-xref>.
    1. Let _sourceString_ be the string-concatenation of _prefix_, *" anonymous("*, _P_, 0x000A (LINE FEED), *") {"*, _bodyString_, and *"}"*.
    1. <ins>Set _sourceString_ to be ? ToString(HostValidateDynamicCode(_callerRealm_, _calleeRealm_, _sourceString_, _assembledFromCodeLike_)). </ins>
    1. ...
  </emu-alg>
</emu-clause>

<emu-annex id="sec-host-layering-points">
  <h1>Host Layering Points</h1>
  <emu-annex id="sec-host-defined-fields-summary">
    <h1>Host-defined Fields</h1>
    <p>
    <ins>[[HostDefinedCodeLike]]: See IsCodeLike</ins>
    </p>
  </emu-annex>
</emu-annex>